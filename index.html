<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HIGHWAY RUSH 3D</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;600;700;900&family=Orbitron:wght@700;900&display=swap"
        rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="js/tailwind-config.js"></script>
    <link rel="stylesheet" href="css/style.css">
</head>

<body class="overflow-hidden h-screen transition-all duration-1000" id="app-body"
    style="background: linear-gradient(135deg, rgb(15, 23, 42) 0%, rgb(88, 28, 135) 50%, rgb(15, 23, 42) 100%);">
    <div id="app" class="w-screen h-screen relative">
        <canvas id="renderCanvas" class="w-full h-full block"></canvas>

        <!-- Start Screen -->
        <div v-if="!gameRunning"
            class="absolute inset-0 flex flex-col items-center justify-center glass-effect transition-opacity duration-500 z-50"
            :class="{ 'opacity-0 pointer-events-none': gameRunning }">
            <h1
                class="font-orbitron text-6xl md:text-8xl font-black mb-3 md:mb-5 tracking-widest gradient-text animate-float text-center">
                HIGHWAY RUSH 3D
            </h1>
            <p
                class="font-exo text-lg md:text-2xl text-cyan-400 uppercase tracking-widest mb-8 md:mb-12 animate-pulse-glow text-center px-4">
                Speed Unchained, Spirit Untamed
            </p>
            <div class="text-white/70 text-sm md:text-base mb-8 text-center px-4">
                <p v-if="isMobile" class="mb-3">üëà Swipe left/right to move lanes üëâ</p>
                <p v-else class="mb-3">‚¨ÖÔ∏è Use Arrow Keys to move lanes ‚û°Ô∏è</p>
                <p>Collect power-ups: Shield üõ°Ô∏è Magnet üß≤ Slow ‚è±Ô∏è Boost ‚ö°</p>
            </div>
            <button @click="startGame"
                class="font-exo text-2xl md:text-3xl font-bold px-10 md:px-16 py-4 md:py-5 bg-gradient-to-r from-purple-600 to-purple-800 text-white rounded-full uppercase tracking-wider shadow-2xl hover:shadow-purple-500/50 transition-all duration-300 hover:-translate-y-1">
                Start Game
            </button>
        </div>

        <!-- HUD -->
        <div v-show="gameRunning" :class="themeColors.text"
            class="absolute top-0 left-0 right-0 p-3 md:p-6 flex justify-between z-10 pointer-events-none">
            <!-- Left HUD -->
            <div class="flex flex-col gap-2 md:gap-4">
                <div class="modern-card px-4 md:px-6 py-3 md:py-4 rounded-xl md:rounded-2xl flex items-center gap-3 md:gap-4 backdrop-blur-xl border-2 transition-all duration-300 hover:scale-105"
                    :class="{ 'border-cyan-400/60 shadow-lg shadow-cyan-500/30 bg-cyan-500/10': currentTheme === 'night', 'border-fuchsia-400/60 shadow-lg shadow-fuchsia-500/30 bg-fuchsia-500/10': currentTheme === 'neon', 'border-blue-400/60 shadow-lg shadow-blue-500/30 bg-blue-500/10': currentTheme === 'cyberpunk', 'border-amber-400/60 shadow-lg shadow-amber-500/30 bg-amber-500/10': currentTheme === 'sunset' }">
                    <span class="text-2xl md:text-3xl animate-bounce">üí∞</span>
                    <div class="flex flex-col">
                        <span class="text-xs opacity-70 uppercase tracking-wider">Coins</span>
                        <span class="text-lg md:text-2xl font-black">{{ coins }}</span>
                    </div>
                </div>
                <div class="modern-card px-4 md:px-6 py-3 md:py-4 rounded-xl md:rounded-2xl flex items-center gap-3 md:gap-4 backdrop-blur-xl border-2 transition-all duration-300 hover:scale-105"
                    :class="{ 'border-cyan-400/60 shadow-lg shadow-cyan-500/30 bg-cyan-500/10': currentTheme === 'night', 'border-fuchsia-400/60 shadow-lg shadow-fuchsia-500/30 bg-fuchsia-500/10': currentTheme === 'neon', 'border-blue-400/60 shadow-lg shadow-blue-500/30 bg-blue-500/10': currentTheme === 'cyberpunk', 'border-amber-400/60 shadow-lg shadow-amber-500/30 bg-amber-500/10': currentTheme === 'sunset' }">
                    <span class="text-2xl md:text-3xl">‚ö°</span>
                    <div class="flex flex-col">
                        <span class="text-xs opacity-70 uppercase tracking-wider">Score</span>
                        <span class="text-lg md:text-2xl font-black">{{ score }}</span>
                    </div>
                </div>
                <div class="modern-card px-4 md:px-6 py-3 md:py-5 rounded-xl md:rounded-2xl backdrop-blur-xl border-2 hidden md:block transition-all duration-300 hover:scale-105"
                    :class="{ 'border-cyan-400/60 shadow-lg shadow-cyan-500/30 bg-cyan-500/10': currentTheme === 'night', 'border-fuchsia-400/60 shadow-lg shadow-fuchsia-500/30 bg-fuchsia-500/10': currentTheme === 'neon', 'border-blue-400/60 shadow-lg shadow-blue-500/30 bg-blue-500/10': currentTheme === 'cyberpunk', 'border-amber-400/60 shadow-lg shadow-amber-500/30 bg-amber-500/10': currentTheme === 'sunset' }">
                    <div class="flex justify-between items-center mb-3 text-white font-bold">
                        <span class="text-xs uppercase tracking-wide">Level {{ level }}</span>
                        <span class="text-2xl md:text-3xl font-black">{{
                            Math.floor(levelProgress) }}%</span>
                    </div>
                    <div class="w-40 md:w-56 h-3 bg-white/10 rounded-full overflow-hidden border border-white/20">
                        <div class="h-full bg-gradient-to-r from-cyan-400 to-purple-600 rounded-full transition-all duration-300 shadow-lg"
                            :style="{ width: levelProgress + '%' }"></div>
                    </div>
                </div>
            </div>

            <!-- Right HUD -->
            <div class="flex flex-col gap-2 md:gap-4">
                <div class="modern-card px-4 md:px-6 py-3 md:py-4 rounded-xl md:rounded-2xl flex items-center gap-3 md:gap-4 backdrop-blur-xl border-2 transition-all duration-300 hover:scale-105"
                    :class="{ 'border-cyan-400/60 shadow-lg shadow-cyan-500/30 bg-cyan-500/10': currentTheme === 'night', 'border-fuchsia-400/60 shadow-lg shadow-fuchsia-500/30 bg-fuchsia-500/10': currentTheme === 'neon', 'border-blue-400/60 shadow-lg shadow-blue-500/30 bg-blue-500/10': currentTheme === 'cyberpunk', 'border-amber-400/60 shadow-lg shadow-amber-500/30 bg-amber-500/10': currentTheme === 'sunset' }">
                    <span class="text-2xl md:text-3xl">üèÜ</span>
                    <div class="flex flex-col">
                        <span class="text-xs opacity-70 uppercase tracking-wider">Best</span>
                        <span class="text-lg md:text-2xl font-black">{{ bestScore }}</span>
                    </div>
                </div>
                <div class="modern-card px-4 md:px-6 py-3 md:py-4 rounded-xl md:rounded-2xl flex items-center gap-3 md:gap-4 backdrop-blur-xl border-2 transition-all duration-300 hover:scale-105"
                    :class="{ 'border-cyan-400/60 shadow-lg shadow-cyan-500/30 bg-cyan-500/10': currentTheme === 'night', 'border-fuchsia-400/60 shadow-lg shadow-fuchsia-500/30 bg-fuchsia-500/10': currentTheme === 'neon', 'border-blue-400/60 shadow-lg shadow-blue-500/30 bg-blue-500/10': currentTheme === 'cyberpunk', 'border-amber-400/60 shadow-lg shadow-amber-500/30 bg-amber-500/10': currentTheme === 'sunset' }">
                    <span class="text-2xl md:text-3xl" :class="combo > 0 ? 'animate-pulse' : ''">üî•</span>
                    <div class="flex flex-col">
                        <span class="text-xs opacity-70 uppercase tracking-wider">Combo</span>
                        <span class="text-lg md:text-2xl font-black">{{ combo }}x</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Speed Meter -->
        <div v-show="gameRunning"
            class="absolute bottom-24 md:bottom-10 right-3 md:right-10 w-24 md:w-32 h-24 md:h-32 z-10 pointer-events-none">
            <div class="w-full h-full rounded-full modern-card border-3 backdrop-blur-xl flex flex-col items-center justify-center shadow-2xl"
                :class="getSpeedMeterClass()">
                <div class="text-3xl md:text-4xl font-black" :class="themeColors.text">{{ speedKmh }}</div>
                <div class="text-white/70 text-xs uppercase tracking-widest mt-1">KM/H</div>
            </div>
        </div>

        <!-- Mobile Lane Indicators -->
        <!-- <div v-show="gameRunning && isMobile"
            class="absolute top-32 left-0 right-0 flex justify-center gap-2 px-2 z-10 pointer-events-none">
            <div v-for="lane in 4" :key="lane"
                class="w-10 h-14 rounded-lg transition-all duration-200 backdrop-blur border-2"
                :class="lane - 1 === targetLane ? 'bg-cyan-400/40 border-cyan-400 shadow-lg shadow-cyan-500/50' : 'bg-white/10 border-white/20'">
            </div>
        </div> -->

        <!-- Speed Controller / Accelerator -->
        <div v-show="gameRunning" class="absolute left-3 md:left-6 bottom-3 md:bottom-10 flex flex-col gap-2 z-10">
            <!-- Accelerate Button -->
            <div @mousedown="isAccelerating = true" @mouseup="isAccelerating = false"
                @mouseleave="isAccelerating = false" @touchstart="isAccelerating = true"
                @touchend="isAccelerating = false"
                class="w-14 h-14 md:w-16 md:h-16 modern-card border-3 rounded-lg flex items-center justify-center text-2xl md:text-3xl cursor-pointer transition-all duration-100 pointer-events-auto touch-target backdrop-blur-xl"
                :class="{ 'bg-gradient-to-br from-green-500 to-emerald-600 border-green-300 shadow-lg shadow-green-500/50 scale-110': isAccelerating, ...getButtonClass() }">
                <span class="select-none">‚¨ÜÔ∏è</span>
            </div>

            <!-- Brake Button -->
            <div @mousedown="isBraking = true" @mouseup="isBraking = false" @mouseleave="isBraking = false"
                @touchstart="isBraking = true" @touchend="isBraking = false"
                class="w-14 h-14 md:w-16 md:h-16 modern-card border-3 rounded-lg flex items-center justify-center text-2xl md:text-3xl cursor-pointer transition-all duration-100 pointer-events-auto touch-target backdrop-blur-xl"
                :class="{ 'bg-gradient-to-br from-red-500 to-red-600 border-red-300 shadow-lg shadow-red-500/50 scale-110': isBraking, ...getButtonClass() }">
                <span class="select-none">‚¨áÔ∏è</span>
            </div>

            <!-- Speed Indicator -->
            <div class="modern-card px-2 md:px-3 py-2 rounded-lg backdrop-blur-xl border-2 text-center"
                :class="{ 'border-cyan-400/60 bg-cyan-500/10': currentTheme === 'night', 'border-fuchsia-400/60 bg-fuchsia-500/10': currentTheme === 'neon', 'border-blue-400/60 bg-blue-500/10': currentTheme === 'cyberpunk', 'border-amber-400/60 bg-amber-500/10': currentTheme === 'sunset' }">
                <div class="text-xs md:text-sm opacity-70 uppercase tracking-wider" :class="themeColors.text">Speed</div>
                <div class="text-sm md:text-base font-black" :class="themeColors.text">{{ (speedMultiplier *
                    100).toFixed(0) }}%</div>
            </div>
        </div>

        <!-- Power-ups -->
        <div v-show="gameRunning"
            class="absolute bottom-3 md:bottom-10 left-1/2 -translate-x-1/2 flex gap-2 md:gap-5 z-10">
            <div @click="activatePower('shield')"
                class="w-16 h-16 md:w-20 md:h-20 modern-card border-3 rounded-full flex items-center justify-center text-3xl md:text-4xl cursor-pointer transition-all duration-300 hover:scale-125 pointer-events-auto relative power-btn touch-target backdrop-blur-xl"
                :class="{ 'active bg-gradient-to-br from-yellow-500 to-yellow-600 border-yellow-300 shadow-lg shadow-yellow-500/50': shieldActive, 'opacity-30 cursor-not-allowed': shieldCooldown > 0, [getPowerButtonClass()]: !shieldActive }">
                üõ°Ô∏è
                <div v-if="shieldCooldown > 0"
                    class="absolute -bottom-6 md:-bottom-8 left-1/2 -translate-x-1/2 text-xs md:text-sm text-yellow-300 font-bold whitespace-nowrap">
                    {{ Math.ceil(shieldCooldown / 60) }}s
                </div>
            </div>
            <div @click="activatePower('magnet')"
                class="w-16 h-16 md:w-20 md:h-20 modern-card border-3 rounded-full flex items-center justify-center text-3xl md:text-4xl cursor-pointer transition-all duration-300 hover:scale-125 pointer-events-auto relative power-btn touch-target backdrop-blur-xl"
                :class="{ 'active bg-gradient-to-br from-red-500 to-red-600 border-red-300 shadow-lg shadow-red-500/50': magnetActive, 'opacity-30 cursor-not-allowed': magnetCooldown > 0, [getPowerButtonClass()]: !magnetActive }">
                üß≤
                <div v-if="magnetCooldown > 0"
                    class="absolute -bottom-6 md:-bottom-8 left-1/2 -translate-x-1/2 text-xs md:text-sm text-red-300 font-bold whitespace-nowrap">
                    {{ Math.ceil(magnetCooldown / 60) }}s
                </div>
            </div>
            <div @click="activatePower('slow')"
                class="w-16 h-16 md:w-20 md:h-20 modern-card border-3 rounded-full flex items-center justify-center text-3xl md:text-4xl cursor-pointer transition-all duration-300 hover:scale-125 pointer-events-auto relative power-btn touch-target backdrop-blur-xl"
                :class="{ 'active bg-gradient-to-br from-blue-500 to-blue-600 border-blue-300 shadow-lg shadow-blue-500/50': slowActive, 'opacity-30 cursor-not-allowed': slowCooldown > 0, [getPowerButtonClass()]: !slowActive }">
                ‚è±Ô∏è
                <div v-if="slowCooldown > 0"
                    class="absolute -bottom-6 md:-bottom-8 left-1/2 -translate-x-1/2 text-xs md:text-sm text-blue-300 font-bold whitespace-nowrap">
                    {{ Math.ceil(slowCooldown / 60) }}s
                </div>
            </div>
            <div @click="activatePower('boost')"
                class="w-16 h-16 md:w-20 md:h-20 modern-card border-3 rounded-full flex items-center justify-center text-3xl md:text-4xl cursor-pointer transition-all duration-300 hover:scale-125 pointer-events-auto relative power-btn touch-target backdrop-blur-xl"
                :class="{ 'active bg-gradient-to-br from-pink-500 to-pink-600 border-pink-300 shadow-lg shadow-pink-500/50': boostActive, 'opacity-30 cursor-not-allowed': boostCooldown > 0, [getPowerButtonClass()]: !boostActive }">
                ‚ö°
                <div v-if="boostCooldown > 0"
                    class="absolute -bottom-6 md:-bottom-8 left-1/2 -translate-x-1/2 text-xs md:text-sm text-pink-300 font-bold whitespace-nowrap">
                    {{ Math.ceil(boostCooldown / 60) }}s
                </div>
            </div>
        </div>

        <!-- Sound Toggle Button -->
        <div v-show="gameRunning" class="absolute top-3 md:top-6 left-1/2 -translate-x-1/2 z-10">
            <button @click="toggleSound"
                class="w-12 h-12 md:w-14 md:h-14 modern-card border-2 rounded-full flex items-center justify-center text-2xl md:text-3xl cursor-pointer transition-all duration-300 hover:scale-110 pointer-events-auto touch-target backdrop-blur-xl"
                :class="getSoundButtonClass()">
                <span v-if="soundEnabled">üîä</span>
                <span v-else>üîá</span>
            </button>
        </div>

        <!-- Combo Display -->
        <div class="combo-display absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 font-orbitron text-7xl font-black text-yellow-400 pointer-events-none z-50 opacity-0"
            :class="{ 'show': showComboAnim }" style="text-shadow: 0 0 30px #ffbe0b;">
            {{ combo }}x COMBO!
        </div>

        <!-- Game Over -->
        <div v-if="gameOver"
            class="absolute inset-0 flex flex-col items-center justify-center glass-effect transition-opacity duration-500 z-50 p-4">
            <h2 class="font-orbitron text-5xl md:text-7xl font-black mb-6 md:mb-10 text-pink-500 animate-float text-center"
                style="text-shadow: 0 0 40px #ff006e;">
                GAME OVER
            </h2>
            <div
                class="glass-effect px-6 md:px-14 py-6 md:py-10 rounded-2xl md:rounded-3xl border-2 border-cyan-400/40 mb-6 md:mb-10 w-full max-w-md">
                <div
                    class="flex justify-between items-center gap-8 md:gap-16 my-3 md:my-4 text-sm md:text-xl text-white">
                    <span class="font-semibold">Final Score</span>
                    <span class="text-2xl md:text-3xl font-black text-cyan-400">{{ score }}</span>
                </div>
                <div
                    class="flex justify-between items-center gap-8 md:gap-16 my-3 md:my-4 text-sm md:text-xl text-white">
                    <span class="font-semibold">Coins Collected</span>
                    <span class="text-2xl md:text-3xl font-black text-cyan-400">{{ coins }}</span>
                </div>
                <div
                    class="flex justify-between items-center gap-8 md:gap-16 my-3 md:my-4 text-sm md:text-xl text-white">
                    <span class="font-semibold">Level Reached</span>
                    <span class="text-2xl md:text-3xl font-black text-cyan-400">{{ level }}</span>
                </div>
                <div
                    class="flex justify-between items-center gap-8 md:gap-16 my-3 md:my-4 text-sm md:text-xl text-white">
                    <span class="font-semibold">Max Combo</span>
                    <span class="text-2xl md:text-3xl font-black text-cyan-400">{{ maxCombo }}x</span>
                </div>
            </div>
            <button @click="startGame"
                class="font-exo text-xl md:text-3xl font-bold px-8 md:px-16 py-3 md:py-5 bg-gradient-to-r from-purple-600 to-purple-800 text-white rounded-full uppercase tracking-wider shadow-2xl hover:shadow-purple-500/50 transition-all duration-300 hover:-translate-y-1">
                Play Again
            </button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        new Vue({
            el: '#app',
            data: {
                gameRunning: false,
                gameOver: false,
                score: 0,
                coins: 0,
                level: 1,
                combo: 0,
                maxCombo: 0,
                levelProgress: 0,
                bestScore: localStorage.getItem('bestScore') || 0,
                playerLane: 1,
                targetLane: 1,
                speed: 0,
                speedKmh: 0,
                frameCount: 0,
                speedMultiplier: 1,
                maxSpeedMultiplier: 5,
                isAccelerating: false,
                isBraking: false,

                // Power-ups
                shieldActive: false,
                magnetActive: false,
                slowActive: false,
                boostActive: false,
                shieldCooldown: 0,
                magnetCooldown: 0,
                slowCooldown: 0,
                boostCooldown: 0,
                shieldTimer: 0,
                magnetTimer: 0,
                slowTimer: 0,
                boostTimer: 0,

                showComboAnim: false,

                // Touch/Mobile controls
                touchStartX: 0,
                touchStartY: 0,
                isMobile: false,

                // Theme system
                currentTheme: 'nightCity',
                themes: {
                    'nightCity': { bg: 'from-slate-950 via-purple-950 to-slate-950', accent: 'cyan', glow: 'cyan', text: 'text-cyan-300', envType: 'city' },
                    'dayCity': { bg: 'from-blue-300 via-cyan-200 to-blue-200', accent: 'blue', glow: 'blue', text: 'text-blue-700', envType: 'city' },
                    'dayVillage': { bg: 'from-yellow-200 via-green-200 to-yellow-100', accent: 'amber', glow: 'yellow', text: 'text-amber-800', envType: 'village' },
                    'nightVillage': { bg: 'from-indigo-950 via-slate-900 to-indigo-950', accent: 'orange', glow: 'orange', text: 'text-orange-300', envType: 'village' },
                    'dayForest': { bg: 'from-green-300 via-emerald-200 to-green-200', accent: 'green', glow: 'green', text: 'text-green-700', envType: 'forest' },
                    'nightForest': { bg: 'from-slate-950 via-green-950 to-slate-950', accent: 'lime', glow: 'green', text: 'text-lime-300', envType: 'forest' },
                    'sea': { bg: 'from-blue-900 via-teal-900 to-blue-800', accent: 'cyan', glow: 'cyan', text: 'text-cyan-300', envType: 'sea' },
                    'mountain': { bg: 'from-slate-700 via-slate-600 to-slate-700', accent: 'slate', glow: 'white', text: 'text-gray-200', envType: 'mountain' }
                },

                // Sound system
                sounds: null,
                soundEnabled: localStorage.getItem('soundEnabled') !== 'false',
                backgroundMusic: null,

                // Three.js objects
                scene: null,
                camera: null,
                renderer: null,
                playerCar: null,
                cars: [],
                collectibles: [],
                roadSegments: [],
                laneMarkers: [],
                roadEdges: [],
                mountains: [],
                buildings: [],
                sideLights: [],
                shieldMesh: null
            },
            mounted() {
                this.initAudio();
                this.initThreeJS();
                this.createBackground();
                this.createRoad();
                this.createPlayerCar();
                this.updateTheme();
                this.animate();
                this.setupControls();
            },
            computed: {
                themeColors() {
                    return this.themes[this.currentTheme] || this.themes['night'];
                }
            },
            watch: {
                currentTheme(newTheme) {
                    // Trigger background update when theme changes
                    this.$nextTick(() => {
                        const body = document.getElementById('app-body');
                        if (body) {
                            const gradient = this.getThemeGradient();
                            body.style.background = `linear-gradient(135deg, ${gradient})`;
                            body.style.transition = 'background 1s ease-in-out';
                        }
                    });
                }
            },
            methods: {
                // ========== SOUND SYSTEM ==========
                initAudio() {
                    // Create audio elements for sound  effects using free sounds from Mixkit
                    this.sounds = {
                        coin: new Audio('https://assets.mixkit.co/active_storage/sfx/2000/2000-preview.mp3'),
                        powerup: new Audio('https://assets.mixkit.co/active_storage/sfx/2018/2018-preview.mp3'),
                        crash: new Audio('https://assets.mixkit.co/active_storage/sfx/2020/2020-preview.mp3'),
                        levelup: new Audio('https://assets.mixkit.co/active_storage/sfx/1435/1435-preview.mp3'),
                        lane: new Audio('https://assets.mixkit.co/active_storage/sfx/2571/2571-preview.mp3'),
                        music: new Audio('sound/vehicle-on-highway.mp3')
                    };

                    // Set volumes
                    this.sounds.coin.volume = 0.4;
                    this.sounds.powerup.volume = 0.5;
                    this.sounds.crash.volume = 0.6;
                    this.sounds.levelup.volume = 0.5;
                    this.sounds.lane.volume = 0.3;
                    this.sounds.music.volume = 0.8;
                    this.sounds.music.loop = true;
                },

                toggleSound() {
                    this.soundEnabled = !this.soundEnabled;
                    localStorage.setItem('soundEnabled', this.soundEnabled);
                    if (!this.soundEnabled && this.backgroundMusic) {
                        this.stopBackgroundMusic();
                    } else if (this.soundEnabled && this.gameRunning && !this.backgroundMusic) {
                        this.playBackgroundMusic();
                    }
                },

                playSound(type) {
                    if (!this.soundEnabled || !this.sounds || !this.sounds[type]) return;

                    try {
                        // Clone and play to allow multiple concurrent sounds
                        const sound = this.sounds[type].cloneNode();
                        sound.volume = this.sounds[type].volume;
                        sound.play().catch(e => console.warn('Sound play failed:', e));
                    } catch (e) {
                        console.warn('Sound playback error:', e);
                    }
                },

                playBackgroundMusic() {
                    if (!this.soundEnabled || !this.sounds || this.backgroundMusic) return;

                    try {
                        this.sounds.music.currentTime = 0;
                        this.sounds.music.play().catch(e => console.warn('Music play failed:', e));
                        this.backgroundMusic = true;
                    } catch (e) {
                        console.warn('Music playback error:', e);
                    }
                },

                stopBackgroundMusic() {
                    if (this.sounds && this.sounds.music) {
                        this.sounds.music.pause();
                        this.sounds.music.currentTime = 0;
                    }
                    this.backgroundMusic = null;
                },

                // ========== GAME LOGIC ==========
                updateTheme() {
                    // Change theme based on level - cycle through 8 themes
                    const themeList = ['nightCity', 'dayCity', 'dayVillage', 'nightVillage', 'dayForest', 'nightForest', 'sea', 'mountain'];
                    const themeIndex = Math.floor((this.level - 1) / 2) % themeList.length;
                    this.currentTheme = themeList[themeIndex];
                    // Recreate background when theme changes significantly
                    if (this.level % 2 === 1 && this.level > 1) {
                        this.recreateBackground();
                    }
                },

                initThreeJS() {
                    const canvas = document.getElementById('renderCanvas');
                    this.scene = new THREE.Scene();
                    this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.renderer.shadowMap.enabled = true;

                    // Lighting
                    const ambientLight = new THREE.AmbientLight(0x404040, 2);
                    this.scene.add(ambientLight);

                    const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
                    directionalLight.position.set(5, 20, 5);
                    directionalLight.castShadow = true;
                    this.scene.add(directionalLight);

                    const pointLight = new THREE.PointLight(0x00f5ff, 2, 100);
                    pointLight.position.set(0, 10, 10);
                    this.scene.add(pointLight);

                    // Camera position
                    this.camera.position.set(0, 8, 15);
                    this.camera.lookAt(0, 0, 0);

                    window.addEventListener('resize', () => {
                        this.camera.aspect = window.innerWidth / window.innerHeight;
                        this.camera.updateProjectionMatrix();
                        this.renderer.setSize(window.innerWidth, window.innerHeight);
                    });
                },

                getSpeedMeterClass() {
                    const meterStyles = {
                        'nightCity': 'border-cyan-400/60 shadow-cyan-500/50 bg-cyan-500/10',
                        'dayCity': 'border-blue-400/60 shadow-blue-500/50 bg-blue-500/10',
                        'dayVillage': 'border-yellow-400/60 shadow-yellow-500/50 bg-yellow-500/10',
                        'nightVillage': 'border-orange-400/60 shadow-orange-500/50 bg-orange-500/10',
                        'dayForest': 'border-green-400/60 shadow-green-500/50 bg-green-500/10',
                        'nightForest': 'border-lime-400/60 shadow-lime-500/50 bg-lime-500/10',
                        'sea': 'border-cyan-400/60 shadow-cyan-500/50 bg-cyan-500/10',
                        'mountain': 'border-gray-300/60 shadow-gray-400/50 bg-gray-500/10'
                    };
                    return meterStyles[this.currentTheme] || meterStyles.nightCity;
                },

                getButtonClass() {
                    const buttonStyles = {
                        'nightCity': 'border-cyan-400/60 shadow-cyan-500/30 bg-cyan-500/10 hover:border-cyan-400',
                        'dayCity': 'border-blue-400/60 shadow-blue-500/30 bg-blue-500/10 hover:border-blue-400',
                        'dayVillage': 'border-yellow-400/60 shadow-yellow-500/30 bg-yellow-500/10 hover:border-yellow-400',
                        'nightVillage': 'border-orange-400/60 shadow-orange-500/30 bg-orange-500/10 hover:border-orange-400',
                        'dayForest': 'border-green-400/60 shadow-green-500/30 bg-green-500/10 hover:border-green-400',
                        'nightForest': 'border-lime-400/60 shadow-lime-500/30 bg-lime-500/10 hover:border-lime-400',
                        'sea': 'border-cyan-400/60 shadow-cyan-500/30 bg-cyan-500/10 hover:border-cyan-400',
                        'mountain': 'border-yellow-400/60 shadow-yellow-500/30 bg-yellow-500/10 hover:border-yellow-400'
                    };
                    return { [buttonStyles[this.currentTheme] || buttonStyles.nightCity]: true };
                },

                getPowerButtonClass(powerType) {
                    const baseClass = {
                        'nightCity': 'border-cyan-400/60 shadow-cyan-500/30 bg-cyan-500/10 hover:shadow-cyan-400',
                        'dayCity': 'border-blue-400/60 shadow-blue-500/30 bg-blue-500/10 hover:shadow-blue-400',
                        'dayVillage': 'border-yellow-400/60 shadow-yellow-500/30 bg-yellow-500/10 hover:shadow-yellow-400',
                        'nightVillage': 'border-orange-400/60 shadow-orange-500/30 bg-orange-500/10 hover:shadow-orange-400',
                        'dayForest': 'border-green-400/60 shadow-green-500/30 bg-green-500/10 hover:shadow-green-400',
                        'nightForest': 'border-lime-400/60 shadow-lime-500/30 bg-lime-500/10 hover:shadow-lime-400',
                        'sea': 'border-cyan-400/60 shadow-cyan-500/30 bg-cyan-500/10 hover:shadow-cyan-400',
                        'mountain': 'border-yellow-400/60 shadow-yellow-500/30 bg-yellow-500/10 hover:shadow-yellow-400'
                    };
                    return baseClass[this.currentTheme] || baseClass.nightCity;
                },

                getSoundButtonClass() {
                    const soundStyles = {
                        'nightCity': 'border-cyan-400/60 shadow-cyan-500/30 bg-cyan-500/10 hover:shadow-cyan-400',
                        'dayCity': 'border-blue-400/60 shadow-blue-500/30 bg-blue-500/10 hover:shadow-blue-400',
                        'dayVillage': 'border-yellow-400/60 shadow-yellow-500/30 bg-yellow-500/10 hover:shadow-yellow-400',
                        'nightVillage': 'border-orange-400/60 shadow-orange-500/30 bg-orange-500/10 hover:shadow-orange-400',
                        'dayForest': 'border-green-400/60 shadow-green-500/30 bg-green-500/10 hover:shadow-green-400',
                        'nightForest': 'border-lime-400/60 shadow-lime-500/30 bg-lime-500/10 hover:shadow-lime-400',
                        'sea': 'border-cyan-400/60 shadow-cyan-500/30 bg-cyan-500/10 hover:shadow-cyan-400',
                        'mountain': 'border-yellow-400/60 shadow-yellow-500/30 bg-yellow-500/10 hover:shadow-yellow-400'
                    };
                    return { [soundStyles[this.currentTheme] || soundStyles.nightCity]: true };
                },

                createBackground() {
                    const skyColors = {
                        'nightCity': { top: 0x0a0a1a, bottom: 0x1a1a3e },
                        'dayCity': { top: 0x87ceeb, bottom: 0xadd8e6 },
                        'dayVillage': { top: 0xffff88, bottom: 0x90ee90 },
                        'nightVillage': { top: 0x191970, bottom: 0x2f4f4f },
                        'dayForest': { top: 0xadff2f, bottom: 0x228b22 },
                        'nightForest': { top: 0x191914, bottom: 0x223e22 },
                        'sea': { top: 0x191f70, bottom: 0x008080 },
                        'mountain': { top: 0x696969, bottom: 0xc0c0c0 }
                    };

                    const colors = skyColors[this.currentTheme] || skyColors.nightCity;

                    // Sky
                    const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
                    const skyMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            topColor: { value: new THREE.Color(colors.top) },
                            bottomColor: { value: new THREE.Color(colors.bottom) }
                        },
                        vertexShader: `
                            varying vec3 vWorldPosition;
                            void main() {
                                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                                vWorldPosition = worldPosition.xyz;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 topColor;
                            uniform vec3 bottomColor;
                            varying vec3 vWorldPosition;
                            void main() {
                                float h = normalize(vWorldPosition).y;
                                gl_FragColor = vec4(mix(bottomColor, topColor, max(h, 0.0)), 1.0);
                            }
                        `,
                        side: THREE.BackSide
                    });
                    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
                    this.scene.add(sky);

                    // Add environment-specific elements based on theme
                    const envType = this.themeColors.envType;

                    if (envType === 'city') {
                        this.createCityEnvironment();
                    } else if (envType === 'village') {
                        this.createVillageEnvironment();
                    } else if (envType === 'forest') {
                        this.createForestEnvironment();
                    } else if (envType === 'sea') {
                        this.createSeaEnvironment();
                    } else if (envType === 'mountain') {
                        this.createMountainEnvironment();
                    }
                },

                createCityEnvironment() {
                    // Stars for night city
                    if (this.currentTheme === 'nightCity') {
                        const starsGeometry = new THREE.BufferGeometry();
                        const starsVertices = [];
                        for (let i = 0; i < 1200; i++) {
                            starsVertices.push(
                                (Math.random() - 0.5) * 1000,
                                Math.random() * 200 + 50,
                                (Math.random() - 0.5) * 1000
                            );
                        }
                        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
                        const stars = new THREE.Points(starsGeometry, new THREE.PointsMaterial({ color: 0xffffff, size: 0.8 }));
                        this.scene.add(stars);
                    }

                    // City buildings
                    const buildingColors = this.currentTheme === 'nightCity' ? 
                        [0x1a1a2e, 0x16213e, 0x0f3460] : 
                        [0x808080, 0x696969, 0x778899];

                    for (let i = 0; i < 35; i++) {
                        const buildingColor = buildingColors[Math.floor(Math.random() * buildingColors.length)];
                        const building = new THREE.Mesh(
                            new THREE.BoxGeometry(
                                Math.random() * 10 + 6,
                                Math.random() * 50 + 30,
                                Math.random() * 10 + 6
                            ),
                            new THREE.MeshStandardMaterial({ color: buildingColor, metalness: 0.6, roughness: 0.4 })
                        );

                        const side = Math.random() > 0.5 ? 1 : -1;
                        const x = side * (Math.random() * 85 + 30);

                        building.position.set(x, building.geometry.parameters.height / 2, -100 - Math.random() * 100);
                        building.castShadow = true;
                        this.scene.add(building);
                        this.buildings.push(building);

                        // Add windows for night city
                        if (this.currentTheme === 'nightCity' && Math.random() > 0.3) {
                            const windowCount = Math.floor(building.geometry.parameters.height / 3);
                            for (let w = 0; w < windowCount; w++) {
                                const window = new THREE.Mesh(
                                    new THREE.BoxGeometry(1.5, 1.5, 0.2),
                                    new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: Math.random() * 0.7 + 0.3 })
                                );
                                window.position.y = 2 + w * 3;
                                building.add(window);
                            }
                        }
                    }

                    // Side lights for city
                    const lightColor = this.currentTheme === 'nightCity' ? 0x00f5ff : 0xffaa00;
                    for (let side = 0; side < 2; side++) {
                        for (let i = 0; i < 50; i++) {
                            const light = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.3, 0.3, 15, 8),
                                new THREE.MeshBasicMaterial({
                                    color: lightColor,
                                    emissive: lightColor
                                })
                            );
                            light.position.set(side === 0 ? -16 : 16, 7.5, -i * 20);
                            this.scene.add(light);
                            this.sideLights.push(light);
                        }
                    }
                },

                createVillageEnvironment() {
                    // Mountains in background
                    const mountainColor = this.currentTheme === 'nightVillage' ? 0x2f4f4f : 0x8b7355;
                    for (let i = 0; i < 12; i++) {
                        const mountain = new THREE.Mesh(
                            new THREE.ConeGeometry(Math.random() * 35 + 25, Math.random() * 70 + 50, 8),
                            new THREE.MeshLambertMaterial({ color: mountainColor })
                        );
                        const side = Math.random() > 0.5 ? 1 : -1;
                        const x = side * (Math.random() * 180 + 100);
                        mountain.position.set(x, Math.random() * 15, -250 - Math.random() * 200);
                        this.scene.add(mountain);
                        this.mountains.push(mountain);
                    }

                    // Small houses
                    for (let i = 0; i < 25; i++) {
                        const houseColor = this.currentTheme === 'nightVillage' ? 0x8b4513 : 0xcd853f;
                        const house = new THREE.Mesh(
                            new THREE.BoxGeometry(Math.random() * 6 + 4, Math.random() * 15 + 10, Math.random() * 6 + 4),
                            new THREE.MeshLambertMaterial({ color: houseColor })
                        );
                        const side = Math.random() > 0.5 ? 1 : -1;
                        const x = side * (Math.random() * 90 + 25);
                        house.position.set(x, house.geometry.parameters.height / 2, -80 - Math.random() * 80);
                        this.scene.add(house);
                        this.buildings.push(house);

                        // Roofs
                        const roof = new THREE.Mesh(
                            new THREE.ConeGeometry(house.geometry.parameters.width / 2 + 0.5, 4, 4),
                            new THREE.MeshLambertMaterial({ color: 0x8b0000 })
                        );
                        roof.position.y = house.geometry.parameters.height + 2;
                        house.add(roof);
                    }

                    // Lanterns on sides
                    const lanternColor = this.currentTheme === 'nightVillage' ? 0xffa500 : 0xffff00;
                    for (let i = 0; i < 40; i++) {
                        const lantern = new THREE.Mesh(
                            new THREE.SphereGeometry(0.4, 8, 8),
                            new THREE.MeshBasicMaterial({ color: lanternColor, emissive: lanternColor, emissiveIntensity: this.currentTheme === 'nightVillage' ? 0.8 : 0.3 })
                        );
                        lantern.position.set(Math.random() > 0.5 ? 16 : -16, 5, -i * 20);
                        this.scene.add(lantern);
                        this.sideLights.push(lantern);
                    }
                },

                createForestEnvironment() {
                    // Trees
                    const treeCount = 40;
                    for (let i = 0; i < treeCount; i++) {
                        const trunkColor = this.currentTheme === 'nightForest' ? 0x3d2817 : 0x654321;
                        const foliageColor = this.currentTheme === 'nightForest' ? 0x2d5016 : 0x228b22;

                        // Tree trunk
                        const trunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(1, 1.2, 15, 8),
                            new THREE.MeshLambertMaterial({ color: trunkColor })
                        );
                        const side = Math.random() > 0.5 ? 1 : -1;
                        const x = side * (Math.random() * 100 + 40);
                        const z = -80 - Math.random() * 150;
                        trunk.position.set(x, 7.5, z);
                        this.scene.add(trunk);

                        // Tree foliage (cone)
                        const foliage = new THREE.Mesh(
                            new THREE.ConeGeometry(6, 20, 8),
                            new THREE.MeshLambertMaterial({ color: foliageColor })
                        );
                        foliage.position.set(0, 17, 0);
                        trunk.add(foliage);
                        this.mountains.push(trunk);
                    }

                    // Ground vegetation effect
                    const grassColor = this.currentTheme === 'nightForest' ? 0x1d4d16 : 0x32cd32;
                    for (let i = 0; i < 20; i++) {
                        const bush = new THREE.Mesh(
                            new THREE.SphereGeometry(3, 8, 8),
                            new THREE.MeshLambertMaterial({ color: grassColor })
                        );
                        bush.position.set(
                            (Math.random() - 0.5) * 180,
                            2,
                            -50 - Math.random() * 200
                        );
                        this.scene.add(bush);
                        this.buildings.push(bush);
                    }

                    // Fireflies for night forest
                    if (this.currentTheme === 'nightForest') {
                        for (let i = 0; i < 50; i++) {
                            const firefly = new THREE.Mesh(
                                new THREE.SphereGeometry(0.3, 4, 4),
                                new THREE.MeshBasicMaterial({ color: 0x00ff00, emissive: 0x00ff00 })
                            );
                            firefly.position.set(
                                (Math.random() - 0.5) * 200,
                                Math.random() * 40 + 10,
                                -100 - Math.random() * 200
                            );
                            this.scene.add(firefly);
                            this.sideLights.push(firefly);
                        }
                    }
                },

                createSeaEnvironment() {
                    // Water particles/waves effect
                    const waterColor = 0x006994;
                    const waterGeometry = new THREE.PlaneGeometry(500, 500);
                    const waterMaterial = new THREE.MeshStandardMaterial({
                        color: waterColor,
                        metalness: 0.8,
                        roughness: 0.3,
                        emissive: 0x004d6d,
                        emissiveIntensity: 0.2
                    });
                    const water = new THREE.Mesh(waterGeometry, waterMaterial);
                    water.rotation.x = -Math.PI / 2;
                    water.position.z = -200;
                    water.position.y = -5;
                    this.scene.add(water);

                    // Distant islands
                    for (let i = 0; i < 8; i++) {
                        const island = new THREE.Mesh(
                            new THREE.ConeGeometry(Math.random() * 25 + 15, Math.random() * 30 + 20, 8),
                            new THREE.MeshLambertMaterial({ color: 0x8b7355 })
                        );
                        const side = Math.random() > 0.5 ? 1 : -1;
                        const x = side * (Math.random() * 150 + 100);
                        island.position.set(x, 5, -250 - Math.random() * 200);
                        this.scene.add(island);
                        this.mountains.push(island);
                    }

                    // Light reflections on water
                    for (let i = 0; i < 60; i++) {
                        const light = new THREE.Mesh(
                            new THREE.BoxGeometry(0.5, 0.5, 5),
                            new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: Math.random() * 0.6 })
                        );
                        light.position.set((Math.random() - 0.5) * 200, 2, -i * 20 - Math.random() * 10);
                        this.scene.add(light);
                        this.sideLights.push(light);
                    }
                },

                createMountainEnvironment() {
                    // Large mountains
                    for (let i = 0; i < 20; i++) {
                        const mountain = new THREE.Mesh(
                            new THREE.ConeGeometry(Math.random() * 50 + 40, Math.random() * 100 + 80, 16),
                            new THREE.MeshStandardMaterial({
                                color: i % 2 === 0 ? 0x6b7280 : 0x9ca3af,
                                metalness: 0.4,
                                roughness: 0.7
                            })
                        );
                        const side = Math.random() > 0.5 ? 1 : -1;
                        const x = side * (Math.random() * 200 + 120);
                        mountain.position.set(x, Math.random() * 30, -200 - Math.random() * 300);
                        mountain.castShadow = true;
                        this.scene.add(mountain);
                        this.mountains.push(mountain);
                    }

                    // Snow peaks
                    for (let i = 0; i < 10; i++) {
                        const snowPeak = new THREE.Mesh(
                            new THREE.ConeGeometry(Math.random() * 30 + 20, Math.random() * 60 + 40, 8),
                            new THREE.MeshStandardMaterial({ color: 0xfafafa, metalness: 0.3, roughness: 0.5 })
                        );
                        const side = Math.random() > 0.5 ? 1 : -1;
                        const x = side * (Math.random() * 180 + 150);
                        snowPeak.position.set(x, Math.random() * 60 + 80, -300 - Math.random() * 200);
                        this.scene.add(snowPeak);
                        this.mountains.push(snowPeak);
                    }

                    // Mountain lights
                    for (let i = 0; i < 30; i++) {
                        const light = new THREE.Mesh(
                            new THREE.SphereGeometry(0.5, 8, 8),
                            new THREE.MeshBasicMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.6 })
                        );
                        light.position.set((Math.random() - 0.5) * 180, Math.random() * 100 + 50, -200 - Math.random() * 200);
                        this.scene.add(light);
                        this.sideLights.push(light);
                    }
                },

                recreateBackground() {
                    // Clear existing environment elements
                    this.mountains.forEach(m => this.scene.remove(m));
                    this.buildings.forEach(b => this.scene.remove(b));
                    this.sideLights.forEach(l => this.scene.remove(l));
                    this.mountains = [];
                    this.buildings = [];
                    this.sideLights = [];

                    // Recreate with new theme
                    this.createBackground();
                },

                createRoad() {
                    const LANE_WIDTH = 4;
                    const roadWidth = LANE_WIDTH * 4;
                    this.laneMarkers = [];
                    this.roadEdges = [];

                    // Theme-specific road colors
                    const roadColors = {
                        'nightCity': { road: 0x1a1a2e, marker: 0x00ff88, edge: 0x00d4ff },
                        'dayCity': { road: 0x505050, marker: 0xffff00, edge: 0xffa500 },
                        'dayVillage': { road: 0x696969, marker: 0xfff000, edge: 0xff6347 },
                        'nightVillage': { road: 0x2a2a2a, marker: 0xffa500, edge: 0xff8c00 },
                        'dayForest': { road: 0x556633, marker: 0x00ff00, edge: 0x00ff00 },
                        'nightForest': { road: 0x1a2a1a, marker: 0x00dd00, edge: 0x00ff88 },
                        'sea': { road: 0x1a3a4a, marker: 0x00ffff, edge: 0x0099ff },
                        'mountain': { road: 0x555555, marker: 0xffffff, edge: 0xffd700 }
                    };

                    const colors = roadColors[this.currentTheme] || roadColors.nightCity;

                    for (let i = 0; i < 40; i++) {
                        const road = new THREE.Mesh(
                            new THREE.PlaneGeometry(roadWidth, 30),
                            new THREE.MeshStandardMaterial({ color: colors.road, roughness: 0.7, metalness: 0.2 })
                        );
                        road.rotation.x = -Math.PI / 2;
                        road.position.z = -i * 20;
                        road.receiveShadow = true;
                        this.scene.add(road);
                        this.roadSegments.push(road);

                        // Lane markers
                        for (let lane = 1; lane < 4; lane++) {
                            for (let j = 0; j < 3; j++) {
                                const marker = new THREE.Mesh(
                                    new THREE.BoxGeometry(0.2, 0.08, 3),
                                    new THREE.MeshBasicMaterial({ color: colors.marker, emissive: colors.marker })
                                );
                                marker.position.set(-roadWidth / 2 + lane * LANE_WIDTH, 0.1, -i * 20 - j * 7);
                                marker.userData = { isMarker: true, updateZ: true };
                                this.scene.add(marker);
                                this.laneMarkers.push(marker);
                            }
                        }

                        // Road edges
                        [-roadWidth / 2, roadWidth / 2].forEach(x => {
                            const edge = new THREE.Mesh(
                                new THREE.BoxGeometry(0.5, 0.3, 20),
                                new THREE.MeshBasicMaterial({ color: colors.edge, emissive: colors.edge })
                            );
                            edge.position.set(x, 0.15, -i * 20);
                            edge.userData = { isEdge: true };
                            this.scene.add(edge);
                            this.roadEdges.push(edge);
                        });
                    }
                },

                createPlayerCar() {
                    this.playerCar = this.createCar(0x00d4ff, true);
                    this.playerCar.position.set(this.getLaneX(this.playerLane), 0.5, 5);
                    this.playerCar.rotation.y = Math.PI;
                    this.scene.add(this.playerCar);

                    // Shield
                    this.shieldMesh = new THREE.Mesh(
                        new THREE.SphereGeometry(2.5, 32, 32),
                        new THREE.MeshBasicMaterial({ color: 0xffbe0b, transparent: true, opacity: 0.3 })
                    );
                    this.shieldMesh.visible = false;
                    this.playerCar.add(this.shieldMesh);
                },

                createCar(color, isPlayer = false) {
                    const car = new THREE.Group();

                    // Body
                    const body = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 1, 4),
                        new THREE.MeshStandardMaterial({
                            color: color,
                            metalness: 0.8,
                            roughness: 0.2,
                            emissive: isPlayer ? color : 0x000000,
                            emissiveIntensity: isPlayer ? 0.3 : 0
                        })
                    );
                    body.position.y = 0.5;
                    body.castShadow = true;
                    car.add(body);

                    // Roof
                    const roof = new THREE.Mesh(
                        new THREE.BoxGeometry(1.8, 0.8, 2),
                        body.material
                    );
                    roof.position.set(0, 1.4, -0.3);
                    roof.castShadow = true;
                    car.add(roof);

                    // Windshield
                    const windshield = new THREE.Mesh(
                        new THREE.BoxGeometry(1.7, 0.7, 0.1),
                        new THREE.MeshStandardMaterial({
                            color: 0x4488ff,
                            transparent: true,
                            opacity: 0.5,
                            metalness: 0.9
                        })
                    );
                    windshield.position.set(0, 1.4, 0.6);
                    car.add(windshield);

                    // Wheels
                    const wheelMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.8 });
                    const wheelPositions = [
                        { x: -1.1, z: 1.5 },
                        { x: 1.1, z: 1.5 },
                        { x: -1.1, z: -1.5 },
                        { x: 1.1, z: -1.5 }
                    ];

                    car.userData.wheels = [];
                    wheelPositions.forEach(pos => {
                        const wheel = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16),
                            wheelMaterial
                        );
                        wheel.rotation.z = Math.PI / 2;
                        wheel.position.set(pos.x, 0.4, pos.z);
                        wheel.castShadow = true;
                        car.add(wheel);
                        car.userData.wheels.push(wheel);
                    });

                    // Lights
                    if (isPlayer) {
                        [-0.6, 0.6].forEach(x => {
                            const light = new THREE.Mesh(
                                new THREE.CircleGeometry(0.2, 16),
                                new THREE.MeshBasicMaterial({ color: 0xffff00, emissive: 0xffff00 })
                            );
                            light.position.set(x, 0.4, -2.05);
                            car.add(light);

                            const spotlight = new THREE.SpotLight(0xffff00, 2, 50, Math.PI / 8);
                            spotlight.position.set(x, 0.4, -2);
                            spotlight.target.position.set(x, 0, 30);
                            car.add(spotlight);
                            car.add(spotlight.target);
                        });
                    } else {
                        // Tail lights for enemy cars
                        [-0.7, 0.7].forEach(x => {
                            const tail = new THREE.Mesh(
                                new THREE.BoxGeometry(0.6, 0.15, 0.1),
                                new THREE.MeshBasicMaterial({ color: 0xff0000, emissive: 0xff0000 })
                            );
                            tail.position.set(x, 0.5, 2.05);
                            car.add(tail);
                        });

                        // Turn signal indicators (blinkers)
                        const leftBlinker = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.15, 0.1),
                            new THREE.MeshBasicMaterial({ color: 0xff8800, emissive: 0xff8800, emissiveIntensity: 0 })
                        );
                        leftBlinker.position.set(-0.95, 0.5, 2.05);
                        car.add(leftBlinker);

                        const rightBlinker = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.15, 0.1),
                            new THREE.MeshBasicMaterial({ color: 0xff8800, emissive: 0xff8800, emissiveIntensity: 0 })
                        );
                        rightBlinker.position.set(0.95, 0.5, 2.05);
                        car.add(rightBlinker);

                        // Store blinkers in userData for animation
                        car.userData.leftBlinker = leftBlinker;
                        car.userData.rightBlinker = rightBlinker;
                    }

                    return car;
                },

                createCoin() {
                    const coin = new THREE.Group();
                    const mesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, 0.2, 32),
                        new THREE.MeshStandardMaterial({
                            color: 0xffd700,
                            metalness: 1,
                            roughness: 0.1,
                            emissive: 0xffd700,
                            emissiveIntensity: 0.5
                        })
                    );
                    mesh.rotation.x = Math.PI / 2;
                    coin.add(mesh);
                    return coin;
                },

                createPowerUp(type) {
                    const powerUp = new THREE.Group();
                    const colors = { shield: 0xffbe0b, magnet: 0x00f5ff, slow: 0x06ffa5, boost: 0xff0080 };
                    const color = colors[type];

                    const sphere = new THREE.Mesh(
                        new THREE.SphereGeometry(0.8, 32, 32),
                        new THREE.MeshStandardMaterial({
                            color: color,
                            metalness: 0.8,
                            roughness: 0.2,
                            emissive: color,
                            emissiveIntensity: 0.8
                        })
                    );
                    powerUp.add(sphere);

                    const ring = new THREE.Mesh(
                        new THREE.TorusGeometry(1, 0.1, 16, 32),
                        new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6 })
                    );
                    powerUp.add(ring);
                    powerUp.userData.ring = ring;

                    return powerUp;
                },

                getLaneX(lane) {
                    return -6 + lane * 4;
                },

                startGame() {
                    this.gameRunning = true;
                    this.gameOver = false;
                    this.score = 0;
                    this.coins = 0;
                    this.level = 1;
                    this.combo = 0;
                    this.maxCombo = 0;
                    this.levelProgress = 0;
                    this.speed = 0.3;
                    this.playerLane = 1;
                    this.targetLane = 1;
                    this.frameCount = 0;
                    this.speedMultiplier = 1;
                    this.isAccelerating = false;
                    this.isBraking = false;
                    this.updateTheme();

                    this.cars.forEach(car => this.scene.remove(car));
                    this.collectibles.forEach(item => this.scene.remove(item));
                    this.cars = [];
                    this.collectibles = [];

                    this.playerCar.position.set(this.getLaneX(this.playerLane), 0.5, 5);
                    this.playerCar.rotation.y = Math.PI;
                    this.playerCar.rotation.z = 0;

                    this.shieldActive = false;
                    this.magnetActive = false;
                    this.slowActive = false;
                    this.boostActive = false;
                    this.shieldCooldown = 0;
                    this.magnetCooldown = 0;
                    this.slowCooldown = 0;
                    this.boostCooldown = 0;
                    this.shieldTimer = 0;
                    this.magnetTimer = 0;
                    this.slowTimer = 0;
                    this.boostTimer = 0;
                    this.shieldMesh.visible = false;

                    // Start background music
                    this.playBackgroundMusic();
                },

                update() {
                    if (!this.gameRunning) return;

                    this.frameCount++;

                    const baseSpeed = 0.4 + this.level * 0.03;
                    const adjustedSpeed = baseSpeed * this.speedMultiplier;
                    this.speed = this.slowActive ? adjustedSpeed * 0.5 : adjustedSpeed;
                    this.speedKmh = Math.floor(this.speed * 40);

                    // Speed controller - acceleration/braking
                    if (this.isAccelerating && this.speedMultiplier < this.maxSpeedMultiplier) {
                        this.speedMultiplier += 0.02;
                    } else if (this.isBraking && this.speedMultiplier > 0.5) {
                        this.speedMultiplier -= 0.04;
                    } else if (!this.isAccelerating && !this.isBraking) {
                        // Natural deceleration when not accelerating
                        if (this.speedMultiplier > 1) {
                            this.speedMultiplier -= 0.01;
                        } else if (this.speedMultiplier < 1) {
                            this.speedMultiplier += 0.01;
                        }
                    }
                    this.speedMultiplier = Math.max(0.5, Math.min(this.maxSpeedMultiplier, this.speedMultiplier));

                    // Move road
                    this.roadSegments.forEach(segment => {
                        segment.position.z += this.speed;
                        if (segment.position.z > 20) {
                            segment.position.z -= 800;
                        }
                    });

                    // Move lane markers
                    this.laneMarkers.forEach(marker => {
                        marker.position.z += this.speed;
                        if (marker.position.z > 25) {
                            marker.position.z -= 420;
                        }
                    });

                    // Move road edges
                    this.roadEdges.forEach(edge => {
                        edge.position.z += this.speed;
                        if (edge.position.z > 25) {
                            edge.position.z -= 400;
                        }
                    });

                    // Move background elements
                    this.mountains.forEach(mountain => {
                        mountain.position.z += this.speed * 0.3;
                        if (mountain.position.z > 100) {
                            mountain.position.z -= 400;
                        }
                    });

                    this.buildings.forEach(building => {
                        building.position.z += this.speed * 0.5;
                        if (building.position.z > 50) {
                            building.position.z -= 200;
                        }
                    });

                    this.sideLights.forEach(light => {
                        light.position.z += this.speed;
                        if (light.position.z > 30) {
                            light.position.z -= 1000;
                        }
                    });

                    // Level progress
                    this.levelProgress += 0.1;
                    if (this.levelProgress >= 100) {
                        this.level++;
                        this.levelProgress = 0;
                        this.updateTheme();
                        this.triggerComboAnim();
                        this.playSound('levelup');
                    }

                    // Player movement
                    const currentX = this.playerCar.position.x;
                    const targetX = this.getLaneX(this.targetLane);
                    this.playerCar.position.x += (targetX - currentX) * 0.15;
                    this.playerCar.rotation.z = -(targetX - currentX) * 0.1;
                    this.playerCar.position.y = 0.5 + Math.sin(this.frameCount * 0.15) * 0.05;

                    // Rotate wheels
                    if (this.playerCar.userData.wheels) {
                        this.playerCar.userData.wheels.forEach(wheel => {
                            wheel.rotation.x += this.speed * 0.5;
                        });
                    }

                    // Spawn enemy cars with different behaviors (more cars as level increases)
                    const spawnRate = Math.max(30, 120 - this.level * 8); // Faster spawn at higher levels
                    if (this.frameCount % spawnRate === 0) {
                        const lane = Math.floor(Math.random() * 4);
                        const colors = [0xff006e, 0x8338ec, 0xfb5607, 0x06ffa5, 0xff0080];
                        const enemyCar = this.createCar(colors[Math.floor(Math.random() * colors.length)]);
                        enemyCar.position.set(this.getLaneX(lane), 0.5, -100);

                        // Random car behaviors
                        const behavior = Math.random();
                        let speedMod = 1;
                        let willChangeLane = false;
                        let moveBackward = false;

                        if (behavior < 0.3) {
                            // Fast car (30%)
                            speedMod = 1.5 + Math.random() * 0.5;
                        } else if (behavior < 0.5) {
                            // Slow car (20%)
                            speedMod = 0.5 + Math.random() * 0.3;
                        } else if (behavior < 0.7) {
                            // Lane changer (20%)
                            willChangeLane = true;
                        } else if (behavior < 0.85) {
                            // Backward driver (15%)
                            moveBackward = true;
                        }
                        // else normal car (15%)

                        enemyCar.userData = {
                            lane: lane,
                            speedMod: speedMod,
                            willChangeLane: willChangeLane,
                            moveBackward: moveBackward,
                            laneChangeTimer: 0,
                            laneChangeTarget: lane
                        };
                        this.scene.add(enemyCar);
                        this.cars.push(enemyCar);
                    }

                    // Spawn coins
                    if (this.frameCount % 70 === 0 && Math.random() < 0.7) {
                        const coin = this.createCoin();
                        const lane = Math.floor(Math.random() * 4);
                        coin.position.set(this.getLaneX(lane), 1, -100);
                        coin.userData = { type: 'coin', lane: lane };
                        this.scene.add(coin);
                        this.collectibles.push(coin);
                    }

                    // Spawn power-ups
                    if (this.frameCount % 350 === 0 && Math.random() < 0.4) {
                        const types = ['shield', 'magnet', 'slow', 'boost'];
                        const type = types[Math.floor(Math.random() * types.length)];
                        const powerUp = this.createPowerUp(type);
                        const lane = Math.floor(Math.random() * 4);
                        powerUp.position.set(this.getLaneX(lane), 1, -100);
                        powerUp.userData = { type: type, lane: lane };
                        this.scene.add(powerUp);
                        this.collectibles.push(powerUp);
                    }

                    // Update cars
                    for (let i = this.cars.length - 1; i >= 0; i--) {
                        const car = this.cars[i];
                        const carData = car.userData;

                        // Apply speed modifier and backward behavior
                        const carSpeed = carData.moveBackward ? -this.speed * carData.speedMod : this.speed * carData.speedMod;
                        car.position.z += carSpeed;

                        // Handle lane changes
                        if (carData.willChangeLane) {
                            carData.laneChangeTimer++;

                            // Animate turn signals/blinkers 1 second (60 frames) BEFORE lane change
                            if (carData.laneChangeTimer >= 60 && carData.laneChangeTimer < 120) {
                                // Determine which direction car will turn
                                const willTurnLeft = carData.laneChangeTarget < carData.lane;
                                const willTurnRight = carData.laneChangeTarget > carData.lane;

                                // Blink effect - on/off every 5 frames
                                const blinkOn = Math.floor((carData.laneChangeTimer - 60) / 5) % 2 === 0;
                                const intensity = blinkOn ? 1 : 0;

                                if (carData.leftBlinker && willTurnLeft) {
                                    carData.leftBlinker.material.emissiveIntensity = intensity;
                                }
                                if (carData.rightBlinker && willTurnRight) {
                                    carData.rightBlinker.material.emissiveIntensity = intensity;
                                }
                            } else {
                                // Turn off blinkers when not signaling
                                if (carData.leftBlinker) carData.leftBlinker.material.emissiveIntensity = 0;
                                if (carData.rightBlinker) carData.rightBlinker.material.emissiveIntensity = 0;
                            }

                            if (carData.laneChangeTimer === 120) {
                                // Change lane after signal period
                                carData.laneChangeTarget = Math.floor(Math.random() * 4);
                                carData.laneChangeTimer = 0;
                            }
                        }

                        // Move toward target lane
                        const targetLaneX = this.getLaneX(carData.willChangeLane ? carData.laneChangeTarget : carData.lane);
                        const currentX = car.position.x;
                        car.position.x += (targetLaneX - currentX) * 0.1;
                        car.rotation.z = -(targetLaneX - currentX) * 0.08;

                        if (car.userData.wheels) {
                            car.userData.wheels.forEach(wheel => {
                                wheel.rotation.x += carSpeed * 0.5;
                            });
                        }

                        if (Math.abs(car.userData.lane - this.targetLane) < 0.6 &&
                            car.position.z > 3 && car.position.z < 8) {
                            if (this.shieldActive) {
                                this.scene.remove(car);
                                this.cars.splice(i, 1);
                                this.shieldActive = false;
                                this.shieldTimer = 0;
                                this.shieldMesh.visible = false;
                            } else {
                                this.playSound('crash');
                                this.endGame();
                                return;
                            }
                        }

                        if (car.position.z > 20) {
                            this.scene.remove(car);
                            this.cars.splice(i, 1);
                            this.score += 10 * Math.max(1, this.combo);
                            this.combo = Math.min(this.combo + 1, 10);
                            if (this.combo > this.maxCombo) this.maxCombo = this.combo;
                            if (this.combo % 5 === 0) this.triggerComboAnim();
                        }
                    }

                    // Update collectibles
                    for (let i = this.collectibles.length - 1; i >= 0; i--) {
                        const item = this.collectibles[i];
                        item.position.z += this.speed;
                        item.rotation.y += 0.05;

                        if (item.userData.ring) {
                            item.userData.ring.rotation.x += 0.03;
                        }

                        const collectRadius = this.magnetActive ? 12 : 2; // Increased from 5 to 12

                        // Magnet attraction - pull items toward player (works on all coins, not just same lane)
                        if (this.magnetActive && item.userData.type === 'coin') {
                            const playerX = this.playerCar.position.x;
                            const playerZ = this.playerCar.position.z;
                            const itemX = item.position.x;
                            const itemZ = item.position.z;

                            const dx = playerX - itemX;
                            const dz = playerZ - itemZ;
                            const distance = Math.sqrt(dx * dx + dz * dz);

                            if (distance < collectRadius) {
                                if (distance > 0.1) {
                                    const force = 0.25; // Increased from 0.15 for stronger pull
                                    item.position.x += (dx / distance) * force;
                                    item.position.z += (dz / distance) * force * 0.3; // Also pull forward
                                }
                            }
                        }

                        // Collect if in player lane OR if magnet is active (magnet pulls from all lanes)
                        const canCollect = this.magnetActive ? (item.position.z > 0 && item.position.z < 12) : (Math.abs(item.userData.lane - this.targetLane) < 0.6 && item.position.z > 3 && item.position.z < 8);
                        if (canCollect) {
                            if (item.userData.type === 'coin') {
                                this.coins += 10;
                                this.score += 50;
                                this.playSound('coin');
                            } else {
                                this.activatePower(item.userData.type);
                            }
                            this.scene.remove(item);
                            this.collectibles.splice(i, 1);
                        } else if (item.position.z > 20) {
                            this.scene.remove(item);
                            this.collectibles.splice(i, 1);
                            if (item.userData.type === 'coin') this.combo = 0;
                        }
                    }

                    // Power-up timers
                    if (this.shieldTimer > 0) {
                        this.shieldTimer--;
                        if (this.shieldTimer === 0) {
                            this.shieldActive = false;
                            this.shieldMesh.visible = false;
                        }
                    }
                    if (this.magnetTimer > 0) {
                        this.magnetTimer--;
                        if (this.magnetTimer === 0) this.magnetActive = false;
                    }
                    if (this.slowTimer > 0) {
                        this.slowTimer--;
                        if (this.slowTimer === 0) this.slowActive = false;
                    }
                    if (this.boostTimer > 0) {
                        this.boostTimer--;
                        if (this.boostTimer === 0) this.boostActive = false;
                    }

                    if (this.shieldCooldown > 0) this.shieldCooldown--;
                    if (this.magnetCooldown > 0) this.magnetCooldown--;
                    if (this.slowCooldown > 0) this.slowCooldown--;
                    if (this.boostCooldown > 0) this.boostCooldown--;

                    // Shield animation
                    if (this.shieldActive) {
                        this.shieldMesh.rotation.y += 0.02;
                        const scale = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                        this.shieldMesh.scale.set(scale, scale, scale);
                    }

                    // Camera follow
                    this.camera.position.x += (this.playerCar.position.x * 0.3 - this.camera.position.x) * 0.08;
                    this.camera.lookAt(this.playerCar.position.x, 0, 0);
                },

                activatePower(type) {
                    if (type === 'shield' && this.shieldCooldown === 0) {
                        this.shieldActive = true;
                        this.shieldTimer = 300;
                        this.shieldCooldown = 600;
                        this.shieldMesh.visible = true;
                        this.playSound('powerup');
                    } else if (type === 'magnet' && this.magnetCooldown === 0) {
                        this.magnetActive = true;
                        this.magnetTimer = 300;
                        this.magnetCooldown = 600;
                        this.playSound('powerup');
                    } else if (type === 'slow' && this.slowCooldown === 0) {
                        this.slowActive = true;
                        this.slowTimer = 200;
                        this.slowCooldown = 600;
                        this.playSound('powerup');
                    } else if (type === 'boost' && this.boostCooldown === 0) {
                        this.boostActive = true;
                        this.boostTimer = 150;
                        this.boostCooldown = 600;
                        this.speedMultiplier = 2.0; // Max speed immediately
                        this.playSound('powerup');
                    }
                },

                triggerComboAnim() {
                    this.showComboAnim = true;
                    setTimeout(() => {
                        this.showComboAnim = false;
                    }, 1000);
                },

                endGame() {
                    this.gameRunning = false;
                    this.gameOver = true;
                    this.stopBackgroundMusic();
                    if (this.score > this.bestScore) {
                        this.bestScore = this.score;
                        localStorage.setItem('bestScore', this.bestScore);
                    }
                },

                getThemeGradient() {
                    const gradients = {
                        'nightCity': 'rgb(15, 23, 42) 0%, rgb(88, 28, 135) 50%, rgb(15, 23, 42) 100%',
                        'dayCity': 'rgb(135, 206, 235) 0%, rgb(0, 191, 255) 50%, rgb(135, 206, 250) 100%',
                        'dayVillage': 'rgb(255, 255, 200) 0%, rgb(144, 238, 144) 50%, rgb(255, 250, 165) 100%',
                        'nightVillage': 'rgb(25, 25, 112) 0%, rgb(47, 79, 79) 50%, rgb(25, 25, 112) 100%',
                        'dayForest': 'rgb(173, 255, 47) 0%, rgb(34, 139, 34) 50%, rgb(152, 251, 152) 100%',
                        'nightForest': 'rgb(25, 25, 20) 0%, rgb(34, 61, 34) 50%, rgb(25, 25, 20) 100%',
                        'sea': 'rgb(25, 25, 112) 0%, rgb(0, 128, 128) 50%, rgb(30, 144, 255) 100%',
                        'mountain': 'rgb(105, 105, 105) 0%, rgb(128, 128, 128) 50%, rgb(192, 192, 192) 100%'
                    };
                    return gradients[this.currentTheme] || gradients['nightCity'];
                },

                animate() {
                    requestAnimationFrame(this.animate);
                    this.update();
                    this.renderer.render(this.scene, this.camera);
                },

                setupControls() {
                    // Detect if mobile device
                    this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                    // Keyboard controls
                    document.addEventListener('keydown', (e) => {
                        if (!this.gameRunning) return;

                        if (e.key === 'ArrowLeft' && this.targetLane > 0) {
                            this.targetLane--;
                            this.playSound('lane');
                        } else if (e.key === 'ArrowRight' && this.targetLane < 3) {
                            this.targetLane++;
                            this.playSound('lane');
                        } else if (e.key === ' ' || e.key === 'Spacebar') {
                            e.preventDefault();
                            this.activatePower('shield');
                        } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                            e.preventDefault();
                            this.isAccelerating = true;
                        } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                            e.preventDefault();
                            this.isBraking = true;
                        }
                    });

                    document.addEventListener('keyup', (e) => {
                        if (!this.gameRunning) return;

                        if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
                            this.isAccelerating = false;
                        } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
                            this.isBraking = false;
                        }
                    });

                    // Touch controls - swipe
                    document.addEventListener('touchstart', (e) => {
                        if (!this.gameRunning) return;
                        this.touchStartX = e.touches[0].clientX;
                        this.touchStartY = e.touches[0].clientY;
                    }, false);

                    document.addEventListener('touchmove', (e) => {
                        if (!this.gameRunning) return;
                        e.preventDefault();
                    }, false);

                    document.addEventListener('touchend', (e) => {
                        if (!this.gameRunning) return;
                        const touchEndX = e.changedTouches[0].clientX;
                        const swipeDistance = this.touchStartX - touchEndX;

                        // Swipe left threshold
                        if (swipeDistance < -50 && this.targetLane < 3) {
                            this.targetLane++;
                            this.playSound('lane');
                        }
                        // Swipe right threshold
                        else if (swipeDistance > 50 && this.targetLane > 0) {
                            this.targetLane--;
                            this.playSound('lane');
                        }
                    }, false);
                }
            }
        });
    </script>
</body>

</html>